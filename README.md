# js-substring_search-automaton
Поиск подстроки в строке через ДКА.

**Пример запуска:**

js-substring_search-automaton>node src/auto.js -a -n 18 -t resources/Harry.txt resources/HarrySubStr.txt

**-a**, если установлен, показывается таблица переходов автомата\
**-n number**, если установлен, то выводится number ближайших вхождений подстроки\
**-t**, если установлен, то выводится время работы алгоритма\
**resources/Harry.txt** - текст про Гарри Поттера\
**resources/HarrySubStr.txt** - подстрока "Гарри"

Для примера выше будет выведен результат:\
WorkTime: 16ms\
  Г а р и\
0)1 0 0 0\
1)1 2 0 0\
2)1 0 3 0\
3)1 0 4 0\
4)1 0 0 5\
5)1 0 0 0\
------Entries-----\
|            6652           |\
|            7338           |\
|            7438           |\
|            12939           |\
|            21924           |\
|            22106           |\
|            22513           |\
|            23366           |\
|            23883           |\
|            24276           |\
|            24387           |\
|            25249           |\
|            27604           |\
|            28161           |\
|            28447           |\
|            29810           |\
|            30091           |\
|            30752           |\
--------------------------\

## Структура ДКА
По подстроке строится таблица переходов ДКА, которая каждой паре (состояние, буква) ставит в соответствие состояние.
 - Состояния - префиксы подстроки вкючая пустой префикс и всю строку.
 - Буквы - буквы из алфавита подстроки и символ * для символа не из алфавита.
 - Начальное состояние - пустой префикс.
 - Конечные состояния - вся строка.

## Сложность алгоритма $O(n + m^2)$
Преимущества:
 - Каждый символ строки, в которой мы ищем подстроку, просматривается ровно один раз
 - $O(m^2)$ это сложность построения ДКА, поэтому сложность самого поиска O(n)

Линейное время работы осуществляется за счет того, что функция перехода определяет сдвиги подстроки относительно строки, учитывая возможность суффикса накопленного слова быть префиксом искомого. 

Пусть мы ищем слово "ананас" и находимся в состоянии "анана". Следущая буква в исходной строке оказывается равная "н" и мы не можем зафиксировать вхождение подстроки в строку. Однако мы не потеряем уже накопленную информацию, ведь автомат заместо того, чтобы переходить в состояние пустого префикса, перейдет в состояние "анан".

## Сравнение с алгоритомом Морриса-Пратта
Алгоритм Морриса-Пратта допускает просматривание одного символа исходной строки по нескольку раз. Имеет сложность O(n + m), n - длина строки, m - длина подстроки. Если не учитывать подготовку ДКА, то подход с ДКА выигравает. O(n) vs O(n + m).
